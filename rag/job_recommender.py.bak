"""
Module de recommandation de métiers basé sur RAG.
"""
from typing import List, Dict
import json
import numpy as np
import logging
from embeddings import get_embedder, SBERTEmbeddings
from config import REPOSITORY_PATH, EMBEDDINGS_PATH, SIMILARITY_THRESHOLD, SBERT_MODEL_TYPE

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class JobRecommender:
    """Recommande les métiers les plus adaptés au profil."""
    
    def __init__(
        self,
        repository_path: str = REPOSITORY_PATH,
        embeddings_path: str = EMBEDDINGS_PATH
    ):
        """
        Initialise le recommender.
        
        Args:
            repository_path: Chemin vers le référentiel
            embeddings_path: Chemin vers les embeddings
        """
        with open(repository_path, 'r', encoding='utf-8') as f:
            self.repository = json.load(f)
        
        data = np.load(embeddings_path, allow_pickle=True)
        self.embeddings = data['embeddings']
        self.metadata = json.loads(str(data['metadata']))
        
        self.embedder = get_embedder(SBERT_MODEL_TYPE)
        
        logger.info(f"JobRecommender initialisé avec {len(self.repository)} métiers")
    
    def get_top_recommendations(
        self,
        user_texts: List[str],
        n: int = 3,
        threshold: float = SIMILARITY_THRESHOLD
    ) -> List[Dict]:
        """
        Obtient les top N métiers recommandés.
        
        Args:
            user_texts: Textes décrivant l'utilisateur
            n: Nombre de métiers à recommander
            threshold: Seuil de similarité
        
        Returns:
            Liste de métiers avec scores et détails
        """
        import torch
        
        # Encoder les textes utilisateur
        user_embeddings = self.embedder.encode(user_texts)
        repo_embeddings = torch.from_numpy(self.embeddings).float()
        
        # Calculer similarités
        similarities = self.embedder.cosine_similarity(user_embeddings, repo_embeddings)
        
        # Calculer score par métier
        job_scores = {}
        
        for job_title, job_data in self.repository.items():
            # Récupérer toutes les compétences du métier
            job_competency_ids = []
            job_weights = {}
            
            for block_name, competencies in job_data.items():
                for comp in competencies:
                    job_competency_ids.append(comp['id'])
                    job_weights[comp['id']] = comp['weight']
            
            # Trouver les embeddings correspondants
            matched_scores = []
            matched_comps = []
            missing_comps = []
            
            for comp_id in job_competency_ids:
                # Trouver l'embedding de cette compétence
                comp_indices = [
                    i for i, m in enumerate(self.metadata)
                    if m['competency_id'] == comp_id and m['job_title'] == job_title
                ]
                
                if comp_indices:
                    idx = comp_indices[0]
                    comp_sims = similarities[:, idx]
                    max_sim = comp_sims.max().item()
                    
                    if max_sim >= threshold:
                        matched_scores.append(max_sim * job_weights[comp_id])
                        matched_comps.append(self.metadata[idx]['description'])
                    else:
                        missing_comps.append(self.metadata[idx]['description'])
            
            # Score total pondéré
            total_weight = sum(job_weights.values())
            if total_weight > 0:
                job_score = sum(matched_scores) / total_weight
            else:
                job_score = 0.0
            
            # Niveau de préparation
            match_rate = len(matched_comps) / len(job_competency_ids) if job_competency_ids else 0
            
            if match_rate >= 0.8:
                readiness = "Excellent match - Prêt pour le poste"
            elif match_rate >= 0.6:
                readiness = "Bon match - Quelques compétences à renforcer"
            elif match_rate >= 0.4:
                readiness = "Match moyen - Développement important nécessaire"
            else:
                readiness = "Match faible - Formation substantielle requise"
            
            job_scores[job_title] = {
                'title': job_title,
                'score': job_score,
                'match_rate': match_rate,
                'num_matched_competencies': len(matched_comps),
                'num_required_competencies': len(job_competency_ids),
                'matched_competencies': matched_comps,
                'missing_competencies': missing_comps,
                'readiness': readiness
            }
        
        # Trier et retourner top N
        sorted_jobs = sorted(
            job_scores.values(),
            key=lambda x: x['score'],
            reverse=True
        )
        
        return sorted_jobs[:n]


if __name__ == "__main__":
    print("\nTest du job recommender\n")
    
    recommender = JobRecommender()
    
    user_texts = [
        "Python programming for data science level 4 out of 5",
        "data analysis experience with pandas numpy matplotlib",
        "machine learning level 4 out of 5 with Random Forest"
    ]
    
    recommendations = recommender.get_top_recommendations(user_texts, n=3)
    
    print("Top 3 métiers recommandés:\n")
    for i, job in enumerate(recommendations, 1):
        print(f"{i}. {job['title']}")
        print(f"   Score: {job['score']:.1%}")
        print(f"   Compétences: {job['num_matched_competencies']}/{job['num_required_competencies']}")
        print(f"   {job['readiness']}\n")
